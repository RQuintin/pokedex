{"ast":null,"code":"import _regeneratorRuntime from\"/home/akshaj/projects_js/pokedex/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/home/akshaj/projects_js/pokedex/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{createSlice}from\"@reduxjs/toolkit\";import axios from\"axios\";// A constant that determines how many pokemon are fetched from the API.\nexport var NUMBER_OF_POKEMON=25;// URL for the get request.\nvar URL=\"https://pokeapi.co/api/v2/pokemon?limit=\".concat(NUMBER_OF_POKEMON);// We initialize 2 arrays. pokemonList is where we store all the pokemon fetched.\n// filteredPokemonList is where we store pokemon that match the search filter.\nvar initialState={pokemonList:[],filteredPokemonList:[]};// A function that checks if a pokemon exists in an array.\nvar pokemonExists=function pokemonExists(arr,val){return arr.some(function(arrVal){return val===arrVal;});};export var pokemonCardsSlice=createSlice({name:\"pokemonCards\",initialState:initialState,reducers:{// Add a pokemon to the array. Pokemon is added only if it\n// does not already exist in the state.\nadd:function add(state,action){var existingPokeIds=state.pokemonList.map(function(poke){return poke.id;});if(!pokemonExists(existingPokeIds,action.payload.id)){state.pokemonList.push(action.payload);}},// Search for a pokemon in the pokemonList state. The matches are stored in the\n// filteredPokemonList state.\nsearch:function search(state,action){var searchTerm=action.payload.searchTerm;// If the search term is empty, then pokemonList is\n// returned.\nif(searchTerm===\"\"){state.filteredPokemonList=state.pokemonList;}// Convert the searchTerm and existing pokemon to lowercase while searhcing.\nvar filteredList=state.pokemonList.filter(function(poke){return poke.name.toLowerCase().includes(searchTerm.toLowerCase());});// if searchTerm is not empty and no match is found, return \"xxx\".\n// Else return the filtered list.\nif(searchTerm!==\"\"&&filteredList.length===0){state.filteredPokemonList=[\"xxx\"];}else{state.filteredPokemonList=filteredList;}}}});var _pokemonCardsSlice$ac=pokemonCardsSlice.actions,add=_pokemonCardsSlice$ac.add,search=_pokemonCardsSlice$ac.search;// Async function to fetch pokemon.\n// We only fetch pokemon if they already don't exist in the state.\n// We do this so that a request is not made everytime we go to the explore page.\nexport{add,search};export var fetchPokemonNameUrl=function fetchPokemonNameUrl(){return/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(dispatch,getState){var state,response,data;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:// get state\nstate=getState();_context2.prev=1;if(!(state.pokemon.pokemonList.length!==NUMBER_OF_POKEMON)){_context2.next=8;break;}_context2.next=5;return axios.get(URL);case 5:response=_context2.sent;data=response.data.results;// create a temp object for every pokemon fetched, extract all relevant\n// details into it, and push it into the pokemonList state.\ndata.map(/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(poke){var responseDetails,tempDetails;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return axios.get(poke.url);case 2:responseDetails=_context.sent;tempDetails={id:responseDetails.data.id,name:responseDetails.data.species.name,baseExperience:responseDetails.data.base_experience,height:responseDetails.data.height,weight:responseDetails.data.weight,type:responseDetails.data.types[0].type.name,sprites:responseDetails.data.sprites.front_default};dispatch(add(tempDetails));case 5:case\"end\":return _context.stop();}}},_callee);}));return function(_x3){return _ref2.apply(this,arguments);};}());case 8:_context2.next=13;break;case 10:_context2.prev=10;_context2.t0=_context2[\"catch\"](1);console.log(\"Could not fetch data.\");case 13:case\"end\":return _context2.stop();}}},_callee2,null,[[1,10]]);}));return function(_x,_x2){return _ref.apply(this,arguments);};}();};export var selectorPokemon=function selectorPokemon(state){return state.pokemon.pokemonList;};export var selectorFilteredPokemon=function selectorFilteredPokemon(state){return state.pokemon.filteredPokemonList;};export default pokemonCardsSlice.reducer;","map":{"version":3,"sources":["/home/akshaj/projects_js/pokedex/frontend/src/features/explore/pokemonCardsSlice.js"],"names":["createSlice","axios","NUMBER_OF_POKEMON","URL","initialState","pokemonList","filteredPokemonList","pokemonExists","arr","val","some","arrVal","pokemonCardsSlice","name","reducers","add","state","action","existingPokeIds","map","poke","id","payload","push","search","searchTerm","filteredList","filter","toLowerCase","includes","length","actions","fetchPokemonNameUrl","dispatch","getState","pokemon","get","response","data","results","url","responseDetails","tempDetails","species","baseExperience","base_experience","height","weight","type","types","sprites","front_default","console","log","selectorPokemon","selectorFilteredPokemon","reducer"],"mappings":"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","sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\"\nimport axios from \"axios\"\n\n// A constant that determines how many pokemon are fetched from the API.\nexport const NUMBER_OF_POKEMON = 25\n\n// URL for the get request.\nconst URL = `https://pokeapi.co/api/v2/pokemon?limit=${NUMBER_OF_POKEMON}`\n\n// We initialize 2 arrays. pokemonList is where we store all the pokemon fetched.\n// filteredPokemonList is where we store pokemon that match the search filter.\nconst initialState = {\n  pokemonList: [],\n  filteredPokemonList: [],\n}\n\n// A function that checks if a pokemon exists in an array.\nconst pokemonExists = (arr, val) => {\n  return arr.some(arrVal => val === arrVal)\n}\n\nexport const pokemonCardsSlice = createSlice({\n  name: \"pokemonCards\",\n  initialState: initialState,\n  reducers: {\n    // Add a pokemon to the array. Pokemon is added only if it\n    // does not already exist in the state.\n    add: (state, action) => {\n      const existingPokeIds = state.pokemonList.map(poke => poke.id)\n      if (!pokemonExists(existingPokeIds, action.payload.id)) {\n        state.pokemonList.push(action.payload)\n      }\n    },\n    // Search for a pokemon in the pokemonList state. The matches are stored in the\n    // filteredPokemonList state.\n    search: (state, action) => {\n      const searchTerm = action.payload.searchTerm\n\n      // If the search term is empty, then pokemonList is\n      // returned.\n      if (searchTerm === \"\") {\n        state.filteredPokemonList = state.pokemonList\n      }\n\n      // Convert the searchTerm and existing pokemon to lowercase while searhcing.\n      const filteredList = state.pokemonList.filter(poke =>\n        poke.name.toLowerCase().includes(searchTerm.toLowerCase())\n      )\n\n      // if searchTerm is not empty and no match is found, return \"xxx\".\n      // Else return the filtered list.\n      if (searchTerm !== \"\" && filteredList.length === 0) {\n        state.filteredPokemonList = [\"xxx\"]\n      } else {\n        state.filteredPokemonList = filteredList\n      }\n    },\n  },\n})\n\nexport const { add, search } = pokemonCardsSlice.actions\n\n// Async function to fetch pokemon.\n// We only fetch pokemon if they already don't exist in the state.\n// We do this so that a request is not made everytime we go to the explore page.\nexport const fetchPokemonNameUrl = () => {\n  return async (dispatch, getState) => {\n    // get state\n    const state = getState()\n\n    try {\n      // if length of pokemonList is not equal to NUMBER_OF_POKEMON, then fetch\n      // pokemon.\n      if (state.pokemon.pokemonList.length !== NUMBER_OF_POKEMON) {\n        const response = await axios.get(URL)\n        const data = response.data.results\n\n        // create a temp object for every pokemon fetched, extract all relevant\n        // details into it, and push it into the pokemonList state.\n        data.map(async poke => {\n          const responseDetails = await axios.get(poke.url)\n\n          let tempDetails = {\n            id: responseDetails.data.id,\n            name: responseDetails.data.species.name,\n            baseExperience: responseDetails.data.base_experience,\n            height: responseDetails.data.height,\n            weight: responseDetails.data.weight,\n            type: responseDetails.data.types[0].type.name,\n            sprites: responseDetails.data.sprites.front_default,\n          }\n\n          dispatch(add(tempDetails))\n        })\n      }\n    } catch (e) {\n      console.log(\"Could not fetch data.\")\n    }\n  }\n}\n\nexport const selectorPokemon = state => state.pokemon.pokemonList\nexport const selectorFilteredPokemon = state =>\n  state.pokemon.filteredPokemonList\n\nexport default pokemonCardsSlice.reducer\n"]},"metadata":{},"sourceType":"module"}