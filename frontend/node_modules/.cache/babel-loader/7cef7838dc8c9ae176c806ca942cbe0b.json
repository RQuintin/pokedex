{"ast":null,"code":"import{createSlice}from\"@reduxjs/toolkit\";// intialize a counter for collection id.\nvar collectionId=1;var initialState={collectionList:[]};export var collectionSlice=createSlice({name:\"collection\",initialState:initialState,reducers:{// create a collection only if the same name does not already exists.\ncreate:function create(state,action){if(action.payload!==\"\"){var doesCollectionNameExist=state.collectionList.find(function(cn){return cn.name===action.payload;});if(!doesCollectionNameExist){state.collectionList.push({id:collectionId,name:action.payload,pokemons:[]});collectionId++;}else{alert(\"Collection name \\\"\".concat(action.payload,\"\\\" already exists. Please choose another name.\"));}}else{alert(\"Collection name cannot be blank.\");}},// add pokemon to a collection\nadd:function add(state,action){// get the index of the selected collection in the collectionList array using the collection ID.\nvar collectionListIndex=state.collectionList.findIndex(function(x){return x.id===action.payload.id;});var collectionName=state.collectionList.find(function(c){return c.id===action.payload.id;}).name;// If collection exists, then push the pokemon in it.\nif(collectionListIndex!==-1){if(// If a pokemon with the same name already exists, do not put into the list.\n// Instead, alert the user.\nstate.collectionList[collectionListIndex].pokemons.includes(action.payload.pokemon)){alert(\"\".concat(action.payload.pokemon,\" already exists in collection \\\"\").concat(collectionName,\"\\\".\"));}else{state.collectionList[collectionListIndex].pokemons.push(action.payload.pokemon);}}},// remove a collection.\nremove:function remove(state,action){var collectionIdToRemove=action.payload.id;var collectionIdRemoveIndex=state.collectionList.findIndex(function(col){return col.id===collectionIdToRemove;});if(collectionIdRemoveIndex!==-1){state.collectionList.splice(collectionIdRemoveIndex,1);}},// Edit collection name and pokemon in it.\nedit:function edit(state,action){var collectionIdToEdit=action.payload.id;var editedName=action.payload.editedName;var editedPokemonList=action.payload.editedPokemonList;var collectionIdEditIndex=state.collectionList.findIndex(function(col){return col.id===collectionIdToEdit;});if(collectionIdEditIndex!==-1){state.collectionList[collectionIdEditIndex].name=editedName;state.collectionList[collectionIdEditIndex].pokemons=editedPokemonList;}}}});export var selectorCollection=function selectorCollection(state){return state.collection.collectionList;};var _collectionSlice$acti=collectionSlice.actions,create=_collectionSlice$acti.create,add=_collectionSlice$acti.add,remove=_collectionSlice$acti.remove,edit=_collectionSlice$acti.edit;export{create,add,remove,edit};export default collectionSlice.reducer;","map":{"version":3,"sources":["/home/akshaj/projects_js/pokedex/frontend/src/features/home/collectionSlice.js"],"names":["createSlice","collectionId","initialState","collectionList","collectionSlice","name","reducers","create","state","action","payload","doesCollectionNameExist","find","cn","push","id","pokemons","alert","add","collectionListIndex","findIndex","x","collectionName","c","includes","pokemon","remove","collectionIdToRemove","collectionIdRemoveIndex","col","splice","edit","collectionIdToEdit","editedName","editedPokemonList","collectionIdEditIndex","selectorCollection","collection","actions","reducer"],"mappings":"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","sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\"\n\n// intialize a counter for collection id.\nlet collectionId = 1\n\nconst initialState = {\n  collectionList: [],\n}\n\nexport const collectionSlice = createSlice({\n  name: \"collection\",\n  initialState: initialState,\n  reducers: {\n    // create a collection only if the same name does not already exists.\n    create: (state, action) => {\n      if (action.payload !== \"\") {\n        const doesCollectionNameExist = state.collectionList.find(\n          cn => cn.name === action.payload\n        )\n\n        if (!doesCollectionNameExist) {\n          state.collectionList.push({\n            id: collectionId,\n            name: action.payload,\n            pokemons: [],\n          })\n          collectionId++\n        } else {\n          alert(\n            `Collection name \"${action.payload}\" already exists. Please choose another name.`\n          )\n        }\n      } else {\n        alert(\"Collection name cannot be blank.\")\n      }\n    },\n    // add pokemon to a collection\n    add: (state, action) => {\n      // get the index of the selected collection in the collectionList array using the collection ID.\n      const collectionListIndex = state.collectionList.findIndex(\n        x => x.id === action.payload.id\n      )\n\n      const collectionName = state.collectionList.find(\n        c => c.id === action.payload.id\n      ).name\n\n      // If collection exists, then push the pokemon in it.\n      if (collectionListIndex !== -1) {\n        if (\n          // If a pokemon with the same name already exists, do not put into the list.\n          // Instead, alert the user.\n          state.collectionList[collectionListIndex].pokemons.includes(\n            action.payload.pokemon\n          )\n        ) {\n          alert(\n            `${action.payload.pokemon} already exists in collection \"${collectionName}\".`\n          )\n        } else {\n          state.collectionList[collectionListIndex].pokemons.push(\n            action.payload.pokemon\n          )\n        }\n      }\n    },\n    // remove a collection.\n    remove: (state, action) => {\n      const collectionIdToRemove = action.payload.id\n\n      const collectionIdRemoveIndex = state.collectionList.findIndex(\n        col => col.id === collectionIdToRemove\n      )\n\n      if (collectionIdRemoveIndex !== -1) {\n        state.collectionList.splice(collectionIdRemoveIndex, 1)\n      }\n    },\n    // Edit collection name and pokemon in it.\n    edit: (state, action) => {\n      const collectionIdToEdit = action.payload.id\n      const editedName = action.payload.editedName\n      const editedPokemonList = action.payload.editedPokemonList\n\n      const collectionIdEditIndex = state.collectionList.findIndex(\n        col => col.id === collectionIdToEdit\n      )\n\n      if (collectionIdEditIndex !== -1) {\n        state.collectionList[collectionIdEditIndex].name = editedName\n        state.collectionList[collectionIdEditIndex].pokemons = editedPokemonList\n      }\n    },\n  },\n})\n\nexport const selectorCollection = state => state.collection.collectionList\nexport const { create, add, remove, edit } = collectionSlice.actions\nexport default collectionSlice.reducer\n"]},"metadata":{},"sourceType":"module"}