function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = require('path');
var fs = require('fs');
var babylon = _interopDefault(require('@babel/parser'));
var resolveTailwindConfig = _interopDefault(require('tailwindcss/lib/util/resolveConfig'));
var processPlugins = _interopDefault(require('tailwindcss/lib/util/processPlugins'));
var defaultTailwindConfig = _interopDefault(require('tailwindcss/stubs/defaultConfig.stub'));
var chalk = _interopDefault(require('chalk'));
var timSort = _interopDefault(require('timsort'));
var dset = _interopDefault(require('dset'));
var dlv = _interopDefault(require('dlv'));
var babelPluginMacros = require('babel-plugin-macros');

var SPREAD_ID = '__spread__';
var COMPUTED_ID = '__computed__';

function addImport(ref) {
  var t = ref.types;
  var program = ref.program;
  var mod = ref.mod;
  var name = ref.name;
  var identifier = ref.identifier;

  if (name === 'default') {
    program.unshiftContainer('body', t.importDeclaration([t.importDefaultSpecifier(identifier)], t.stringLiteral(mod)));
  } else {
    program.unshiftContainer('body', t.importDeclaration([t.importSpecifier(identifier, t.identifier(name))], t.stringLiteral(mod)));
  }
}

function assignify(objectAst, t) {
  if (objectAst.type !== 'ObjectExpression') { return objectAst; }
  var cloneNode = t.cloneNode || t.cloneDeep;
  var currentChunk = [];
  var chunks = [];
  objectAst.properties.forEach(function (property) {
    if (property.type === 'SpreadElement') {
      if (currentChunk.length > 0) {
        chunks.push(cloneNode(t.objectExpression(currentChunk)));
        currentChunk.length = 0;
      }

      chunks.push(cloneNode(property.argument));
    } else {
      property.value = assignify(property.value, t);
      currentChunk.push(property);
    }
  });
  if (chunks.length === 0) { return objectAst; }

  if (currentChunk.length > 0) {
    chunks.push(cloneNode(t.objectExpression(currentChunk)));
  }

  return t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('assign')), chunks);
}

function objectExpressionElements(literal, t, spreadType) {
  return Object.keys(literal).filter(function (k) {
    return typeof literal[k] !== 'undefined';
  }).map(function (k) {
    if (k.startsWith(SPREAD_ID)) {
      return t[spreadType](babylon.parseExpression(literal[k]));
    }

    var computed = k.startsWith(COMPUTED_ID);
    var key = computed ? babylon.parseExpression(k.slice(12)) : t.stringLiteral(k);
    return t.objectProperty(key, astify(literal[k], t), computed);
  });
}

function astify(literal, t) {
  if (literal === null) {
    return t.nullLiteral();
  }

  switch (typeof literal) {
    case 'function':
      return t.unaryExpression('void', t.numericLiteral(0), true);

    case 'number':
      return t.numericLiteral(literal);

    case 'boolean':
      return t.booleanLiteral(literal);

    case 'undefined':
      return t.unaryExpression('void', t.numericLiteral(0), true);

    case 'string':
      if (literal.startsWith(COMPUTED_ID)) {
        return babylon.parseExpression(literal.slice(COMPUTED_ID.length));
      }

      return t.stringLiteral(literal);

    default:
      // TODO: When is the literal an array? It's only an object/string
      if (Array.isArray(literal)) {
        return t.arrayExpression(literal.map(function (x) { return astify(x, t); }));
      } // TODO: This is horrible, clean it up


      try {
        return t.objectExpression(objectExpressionElements(literal, t, 'spreadElement'));
      } catch (_) {
        return t.objectExpression(objectExpressionElements(literal, t, 'spreadProperty'));
      }

  }
}

function findIdentifier(ref) {
  var program = ref.program;
  var mod = ref.mod;
  var name = ref.name;

  var identifier = null;
  program.traverse({
    ImportDeclaration: function ImportDeclaration(path$$1) {
      if (path$$1.node.source.value !== mod) { return; }
      path$$1.node.specifiers.some(function (specifier) {
        if (specifier.type === 'ImportDefaultSpecifier' && name === 'default') {
          identifier = specifier.local;
          return true;
        }

        if (specifier.imported.name === name) {
          identifier = specifier.local;
          return true;
        }

        return false;
      });
    }

  });
  return identifier;
}

function parseTte(ref) {
  var path$$1 = ref.path;
  var t = ref.types;
  var styledIdentifier = ref.styledIdentifier;
  var state = ref.state;

  var cloneNode = t.cloneNode || t.cloneDeep;
  if (path$$1.node.tag.type !== 'Identifier' && path$$1.node.tag.type !== 'MemberExpression' && path$$1.node.tag.type !== 'CallExpression') { return null; }
  var string = path$$1.get('quasi').get('quasis')[0].node.value.cooked;
  var stringLoc = path$$1.get('quasi').node.loc;

  if (path$$1.node.tag.type === 'CallExpression') {
    replaceWithLocation(path$$1.get('tag').get('callee'), cloneNode(styledIdentifier));
    state.shouldImportStyled = true;
  } else if (path$$1.node.tag.type === 'MemberExpression') {
    replaceWithLocation(path$$1.get('tag').get('object'), cloneNode(styledIdentifier));
    state.shouldImportStyled = true;
  }

  if (path$$1.node.tag.type === 'CallExpression' || path$$1.node.tag.type === 'MemberExpression') {
    replaceWithLocation(path$$1, t.callExpression(cloneNode(path$$1.node.tag), [t.identifier('__twPlaceholder')]));
    path$$1 = path$$1.get('arguments')[0];
  }

  path$$1.node.loc = stringLoc;
  return {
    string: string,
    path: path$$1
  };
}

function replaceWithLocation(path$$1, replacement) {
  var newPaths = replacement ? path$$1.replaceWith(replacement) : [];

  if (Array.isArray(newPaths) && newPaths.length > 0) {
    var ref = path$$1.node;
    var loc = ref.loc;
    newPaths.forEach(function (p) {
      p.node.loc = loc;
    });
  }

  return newPaths;
}

var dynamicStyles = {
  /**
   * ===========================================
   * Layout
   */
  // https://tailwindcss.com/docs/container
  // TODO: Add container generation plugin
  // https://tailwindcss.com/docs/box-sizing
  // https://tailwindcss.com/docs/display
  // https://tailwindcss.com/docs/float
  // https://tailwindcss.com/docs/clear
  // https://tailwindcss.com/docs/object-fit
  // See staticStyles.js
  // https://tailwindcss.com/docs/object-position
  object: {
    prop: 'objectPosition',
    config: 'objectPosition'
  },
  // https://tailwindcss.com/docs/overflow
  // https://tailwindcss.com/docs/position
  // See staticStyles.js
  // https://tailwindcss.com/docs/top-right-bottom-left
  top: {
    prop: 'top',
    config: 'inset'
  },
  bottom: {
    prop: 'bottom',
    config: 'inset'
  },
  right: {
    prop: 'right',
    config: 'inset'
  },
  left: {
    prop: 'left',
    config: 'inset'
  },
  'inset-y': {
    prop: ['top', 'bottom'],
    config: 'inset'
  },
  'inset-x': {
    prop: ['left', 'right'],
    config: 'inset'
  },
  inset: {
    prop: ['top', 'right', 'bottom', 'left'],
    config: 'inset'
  },
  // https://tailwindcss.com/docs/visibility
  // See staticStyles.js
  // https://tailwindcss.com/docs/z-index
  z: {
    prop: 'zIndex',
    config: 'zIndex'
  },

  /**
   * ===========================================
   * Flexbox
   */
  // https://tailwindcss.com/docs/flex-direction
  // https://tailwindcss.com/docs/flex-wrap
  // https://tailwindcss.com/docs/align-items
  // https://tailwindcss.com/docs/align-content
  // https://tailwindcss.com/docs/align-self
  // https://tailwindcss.com/docs/justify-content
  // See staticStyles.js
  // https://tailwindcss.com/docs/flex-grow
  'flex-grow': {
    prop: 'flexGrow',
    config: 'flexGrow'
  },
  // https://tailwindcss.com/docs/flex-shrink
  'flex-shrink': {
    prop: 'flexShrink',
    config: 'flexShrink'
  },
  // https://tailwindcss.com/docs/flex
  flex: {
    prop: 'flex',
    config: 'flex'
  },
  // https://tailwindcss.com/docs/order
  order: {
    prop: 'order',
    config: 'order'
  },

  /**
   * ===========================================
   * Grid
   */
  // https://tailwindcss.com/docs/grid-template-columns
  'grid-cols': {
    prop: 'gridTemplateColumns',
    config: 'gridTemplateColumns'
  },
  // https://tailwindcss.com/docs/grid-column
  col: {
    prop: 'gridColumn',
    config: 'gridColumn'
  },
  'col-start': {
    prop: 'gridColumnStart',
    config: 'gridColumnStart'
  },
  'col-end': {
    prop: 'gridColumnEnd',
    config: 'gridColumnEnd'
  },
  // https://tailwindcss.com/docs/grid-template-rows
  'grid-rows': {
    prop: 'gridTemplateRows',
    config: 'gridTemplateRows'
  },
  // https://tailwindcss.com/docs/grid-row
  row: {
    prop: 'gridRow',
    config: 'gridRow'
  },
  'row-start': {
    prop: 'gridRowStart',
    config: 'gridRowStart'
  },
  'row-end': {
    prop: 'gridRowEnd',
    config: 'gridRowEnd'
  },
  // https://tailwindcss.com/docs/gap
  gap: {
    prop: 'gap',
    config: 'gap'
  },
  'col-gap': {
    prop: 'columnGap',
    config: 'gap'
  },
  'row-gap': {
    prop: 'rowGap',
    config: 'gap'
  },

  /**
   * ===========================================
   * Spacing
   */
  // https://tailwindcss.com/docs/padding
  pt: {
    prop: 'paddingTop',
    config: 'padding'
  },
  pr: {
    prop: 'paddingRight',
    config: 'padding'
  },
  pb: {
    prop: 'paddingBottom',
    config: 'padding'
  },
  pl: {
    prop: 'paddingLeft',
    config: 'padding'
  },
  px: {
    prop: ['paddingLeft', 'paddingRight'],
    config: 'padding'
  },
  py: {
    prop: ['paddingTop', 'paddingBottom'],
    config: 'padding'
  },
  p: {
    prop: 'padding',
    config: 'padding'
  },
  // https://tailwindcss.com/docs/margin
  mt: {
    prop: 'marginTop',
    config: 'margin'
  },
  mr: {
    prop: 'marginRight',
    config: 'margin'
  },
  mb: {
    prop: 'marginBottom',
    config: 'margin'
  },
  ml: {
    prop: 'marginLeft',
    config: 'margin'
  },
  mx: {
    prop: ['marginLeft', 'marginRight'],
    config: 'margin'
  },
  my: {
    prop: ['marginTop', 'marginBottom'],
    config: 'margin'
  },
  m: {
    prop: 'margin',
    config: 'margin'
  },

  /**
   * ===========================================
   * Sizing
   */
  // https://tailwindcss.com/docs/width
  w: {
    prop: 'width',
    config: 'width'
  },
  // https://tailwindcss.com/docs/min-width
  'min-w': {
    prop: 'minWidth',
    config: 'minWidth'
  },
  // https://tailwindcss.com/docs/max-width
  'max-w': {
    prop: 'maxWidth',
    config: 'maxWidth'
  },
  // https://tailwindcss.com/docs/height
  h: {
    prop: 'height',
    config: 'height'
  },
  // https://tailwindcss.com/docs/min-height
  'min-h': {
    prop: 'minHeight',
    config: 'minHeight'
  },
  // https://tailwindcss.com/docs/max-height
  'max-h': {
    prop: 'maxHeight',
    config: 'maxHeight'
  },

  /**
   * ===========================================
   * Typography
   */
  font: [// https://tailwindcss.com/docs/font-family
  {
    prop: 'fontFamily',
    config: 'fontFamily'
  }, // https://tailwindcss.com/docs/font-weight
  {
    prop: 'fontWeight',
    config: 'fontWeight'
  }],
  // https://tailwindcss.com/docs/font-smoothing
  // https://tailwindcss.com/docs/font-style
  // See staticStyles.js
  // https://tailwindcss.com/docs/letter-spacing
  tracking: {
    prop: 'letterSpacing',
    config: 'letterSpacing'
  },
  // https://tailwindcss.com/docs/line-height
  leading: {
    prop: 'lineHeight',
    config: 'lineHeight'
  },
  // https://tailwindcss.com/docs/list-style-type
  list: {
    prop: 'listStyleType',
    config: 'listStyleType'
  },
  // https://tailwindcss.com/docs/list-style-position
  // See staticStyles.js
  // https://tailwindcss.com/docs/placeholder-color
  placeholder: {
    prop: 'color',
    config: 'placeholderColor'
  },
  // https://tailwindcss.com/docs/text-align
  // See staticStyles.js
  text: [// https://tailwindcss.com/docs/text-color
  {
    prop: 'color',
    config: 'textColor'
  }, // https://tailwindcss.com/docs/font-size
  {
    prop: 'fontSize',
    config: 'fontSize'
  }],
  // https://tailwindcss.com/docs/text-decoration
  // https://tailwindcss.com/docs/text-transform
  // https://tailwindcss.com/docs/vertical-align
  // https://tailwindcss.com/docs/whitespace
  // https://tailwindcss.com/docs/word-break
  // See staticStyles.js

  /**
   * ===========================================
   * Backgrounds
   */
  // https://tailwindcss.com/docs/background-attachment
  // See staticStyles.js
  bg: [// https://tailwindcss.com/docs/background-color
  {
    prop: 'backgroundColor',
    config: 'backgroundColor'
  }, // https://tailwindcss.com/docs/background-size
  {
    prop: 'backgroundSize',
    config: 'backgroundSize'
  }, // https://tailwindcss.com/docs/background-position
  {
    prop: 'backgroundPosition',
    config: 'backgroundPosition'
  }],
  // https://tailwindcss.com/docs/background-repeat
  // See staticStyles.js

  /**
   * ===========================================
   * Borders
   */
  // https://tailwindcss.com/docs/border-style
  // See staticStyles.js
  // https://tailwindcss.com/docs/border-width
  'border-t': {
    prop: 'borderTopWidth',
    config: 'borderWidth'
  },
  'border-b': {
    prop: 'borderBottomWidth',
    config: 'borderWidth'
  },
  'border-l': {
    prop: 'borderLeftWidth',
    config: 'borderWidth'
  },
  'border-r': {
    prop: 'borderRightWidth',
    config: 'borderWidth'
  },
  border: [// https://tailwindcss.com/docs/border-width
  {
    prop: 'borderWidth',
    config: 'borderWidth'
  }, // keep above borderColor to support 'border'
  // https://tailwindcss.com/docs/border-color
  {
    prop: 'borderColor',
    config: 'borderColor'
  }],
  // https://tailwindcss.com/docs/border-radius
  'rounded-tl': {
    prop: 'borderTopLeftRadius',
    config: 'borderRadius'
  },
  'rounded-tr': {
    prop: 'borderTopRightRadius',
    config: 'borderRadius'
  },
  'rounded-br': {
    prop: 'borderBottomRightRadius',
    config: 'borderRadius'
  },
  'rounded-bl': {
    prop: 'borderBottomLeftRadius',
    config: 'borderRadius'
  },
  'rounded-t': {
    prop: ['borderTopLeftRadius', 'borderTopRightRadius'],
    config: 'borderRadius'
  },
  'rounded-r': {
    prop: ['borderTopRightRadius', 'borderBottomRightRadius'],
    config: 'borderRadius'
  },
  'rounded-b': {
    prop: ['borderBottomLeftRadius', 'borderBottomRightRadius'],
    config: 'borderRadius'
  },
  'rounded-l': {
    prop: ['borderTopLeftRadius', 'borderBottomLeftRadius'],
    config: 'borderRadius'
  },
  rounded: {
    prop: 'borderRadius',
    config: 'borderRadius'
  },

  /**
   * ===========================================
   * Tables
   */
  // https://tailwindcss.com/docs/border-collapse
  // https://tailwindcss.com/docs/table-layout
  // See staticStyles.js

  /**
   * ===========================================
   * Effects
   */
  // https://tailwindcss.com/docs/box-shadow
  shadow: {
    prop: 'boxShadow',
    config: 'boxShadow'
  },
  // https://tailwindcss.com/docs/opacity
  opacity: {
    prop: 'opacity',
    config: 'opacity'
  },

  /**
   * ===========================================
   * Transitions
   */
  // https://tailwindcss.com/docs/transition-property
  transition: {
    prop: 'transitionProperty',
    config: 'transitionProperty'
  },
  // https://tailwindcss.com/docs/transition-duration
  duration: {
    prop: 'transitionDuration',
    config: 'transitionDuration'
  },
  // https://tailwindcss.com/docs/transition-timing-function
  ease: {
    prop: 'transitionTimingFunction',
    config: 'transitionTimingFunction'
  },

  /**
   * ===========================================
   * Transforms
   */
  // https://tailwindcss.com/docs/scale
  'scale-x': {
    prop: '--transform-scale-x',
    config: 'scale'
  },
  'scale-y': {
    prop: '--transform-scale-y',
    config: 'scale'
  },
  scale: {
    prop: ['--transform-scale-x', '--transform-scale-y'],
    config: 'scale'
  },
  // https://tailwindcss.com/docs/rotate
  rotate: {
    prop: '--transform-rotate',
    config: 'rotate'
  },
  // https://tailwindcss.com/docs/translate
  'translate-x': {
    prop: '--transform-translate-x',
    config: 'translate'
  },
  'translate-y': {
    prop: '--transform-translate-y',
    config: 'translate'
  },
  // https://tailwindcss.com/docs/skew
  'skew-x': {
    prop: '--transform-skew-x',
    config: 'skew'
  },
  'skew-y': {
    prop: '--transform-skew-y',
    config: 'skew'
  },
  // https://tailwindcss.com/docs/transform-origin
  origin: {
    prop: 'transformOrigin',
    config: 'transformOrigin'
  },

  /**
   * ===========================================
   * Interactivity
   */
  // https://tailwindcss.com/docs/appearance
  // See staticStyles.js
  // https://tailwindcss.com/docs/cursor
  cursor: {
    prop: 'cursor',
    config: 'cursor'
  },
  // https://tailwindcss.com/docs/outline
  // https://tailwindcss.com/docs/pointer-events
  // https://tailwindcss.com/docs/resize
  // https://tailwindcss.com/docs/user-select
  // See staticStyles.js

  /**
   * ===========================================
   * Svg
   */
  // https://tailwindcss.com/docs/fill
  fill: {
    prop: 'fill',
    config: 'fill'
  },
  stroke: [// https://tailwindcss.com/docs/stroke
  {
    prop: 'stroke',
    config: 'stroke'
  }, // https://tailwindcss.com/docs/stroke
  {
    prop: 'strokeWidth',
    config: 'strokeWidth'
  }]
  /**
   * ===========================================
   * Accessibility
   */
  // https://tailwindcss.com/docs/screen-readers
  // See staticStyles.js

};

var staticStyles = {
  /**
   * ===========================================
   * Layout
   */
  // https://tailwindcss.com/docs/container
  // TODO: Add container generation plugin
  // https://tailwindcss.com/docs/box-sizing
  'box-border': {
    output: {
      'box-sizing': 'border-box'
    }
  },
  'box-content': {
    output: {
      'box-sizing': 'content-box'
    }
  },
  // https://tailwindcss.com/docs/display
  hidden: {
    output: {
      display: 'none'
    }
  },
  block: {
    output: {
      display: 'block'
    }
  },
  'inline-block': {
    output: {
      display: 'inline-block'
    }
  },
  inline: {
    output: {
      display: 'inline'
    }
  },
  'flow-root': {
    output: {
      display: 'flow-root'
    }
  },
  flex: {
    output: {
      display: 'flex'
    }
  },
  'inline-flex': {
    output: {
      display: 'inline-flex'
    }
  },
  grid: {
    output: {
      display: 'grid'
    }
  },
  'inline-grid': {
    output: {
      display: 'inline-grid'
    }
  },
  table: {
    output: {
      display: 'table'
    }
  },
  'table-caption': {
    output: {
      display: 'table-caption'
    }
  },
  'table-cell': {
    output: {
      display: 'table-cell'
    }
  },
  'table-column': {
    output: {
      display: 'table-column'
    }
  },
  'table-column-group': {
    output: {
      display: 'table-column-group'
    }
  },
  'table-footer-group': {
    output: {
      display: 'table-footer-group'
    }
  },
  'table-header-group': {
    output: {
      display: 'table-header-group'
    }
  },
  'table-row-group': {
    output: {
      display: 'table-row-group'
    }
  },
  'table-row': {
    output: {
      display: 'table-row'
    }
  },
  // https://tailwindcss.com/docs/float
  'float-right': {
    output: {
      float: 'right'
    }
  },
  'float-left': {
    output: {
      float: 'left'
    }
  },
  'float-none': {
    output: {
      float: 'none'
    }
  },
  clearfix: {
    output: {
      '::after': {
        content: '""',
        display: 'table',
        clear: 'both'
      }
    },
    config: false
  },
  // https://tailwindcss.com/docs/clear
  'clear-left': {
    output: {
      clear: 'left'
    }
  },
  'clear-right': {
    output: {
      clear: 'right'
    }
  },
  'clear-both': {
    output: {
      clear: 'both'
    }
  },
  'clear-none': {
    output: {
      clear: 'none'
    }
  },
  // https://tailwindcss.com/docs/object-fit
  'object-contain': {
    output: {
      objectFit: 'contain'
    }
  },
  'object-cover': {
    output: {
      objectFit: 'cover'
    }
  },
  'object-fill': {
    output: {
      objectFit: 'fill'
    }
  },
  'object-none': {
    output: {
      objectFit: 'none'
    }
  },
  'object-scale-down': {
    output: {
      objectFit: 'scale-down'
    }
  },
  // https://tailwindcss.com/docs/object-position
  // See dynamicStyles.js
  // https://tailwindcss.com/docs/overflow
  'overflow-auto': {
    output: {
      overflow: 'auto'
    },
    config: 'overflow'
  },
  'overflow-hidden': {
    output: {
      overflow: 'hidden'
    },
    config: 'overflow'
  },
  'overflow-visible': {
    output: {
      overflow: 'visible'
    },
    config: 'overflow'
  },
  'overflow-scroll': {
    output: {
      overflow: 'scroll'
    },
    config: 'overflow'
  },
  'overflow-x-auto': {
    output: {
      overflowX: 'auto'
    },
    config: 'overflow'
  },
  'overflow-y-auto': {
    output: {
      overflowY: 'auto'
    },
    config: 'overflow'
  },
  'overflow-x-hidden': {
    output: {
      overflowX: 'hidden'
    },
    config: 'overflow'
  },
  'overflow-y-hidden': {
    output: {
      overflowY: 'hidden'
    },
    config: 'overflow'
  },
  'overflow-x-visible': {
    output: {
      overflowX: 'visible'
    },
    config: 'overflow'
  },
  'overflow-y-visible': {
    output: {
      overflowY: 'visible'
    },
    config: 'overflow'
  },
  'overflow-x-scroll': {
    output: {
      overflowX: 'scroll'
    },
    config: 'overflow'
  },
  'overflow-y-scroll': {
    output: {
      overflowY: 'scroll'
    },
    config: 'overflow'
  },
  'scrolling-touch': {
    output: {
      WebkitOverflowScrolling: 'touch'
    },
    config: false
  },
  'scrolling-auto': {
    output: {
      WebkitOverflowScrolling: 'auto'
    },
    config: false
  },
  // https://tailwindcss.com/docs/position
  static: {
    output: {
      position: 'static'
    }
  },
  fixed: {
    output: {
      position: 'fixed'
    }
  },
  absolute: {
    output: {
      position: 'absolute'
    }
  },
  relative: {
    output: {
      position: 'relative'
    }
  },
  sticky: {
    output: {
      position: 'sticky'
    }
  },
  // https://tailwindcss.com/docs/top-right-bottom-left
  // See dynamicStyles.js
  // https://tailwindcss.com/docs/visibility
  visible: {
    output: {
      visibility: 'visible'
    }
  },
  invisible: {
    output: {
      visibility: 'hidden'
    }
  },
  // https://tailwindcss.com/docs/z-index
  // See dynamicStyles.js

  /**
   * ===========================================
   * Flexbox
   */
  // https://tailwindcss.com/docs/flexbox-direction
  'flex-row': {
    output: {
      flexDirection: 'row'
    }
  },
  'flex-row-reverse': {
    output: {
      flexDirection: 'row-reverse'
    }
  },
  'flex-col': {
    output: {
      flexDirection: 'column'
    }
  },
  'flex-col-reverse': {
    output: {
      flexDirection: 'column-reverse'
    }
  },
  // https://tailwindcss.com/docs/flex-wrap
  'flex-no-wrap': {
    output: {
      flexWrap: 'nowrap'
    }
  },
  'flex-wrap': {
    output: {
      flexWrap: 'wrap'
    }
  },
  'flex-wrap-reverse': {
    output: {
      flexWrap: 'wrap-reverse'
    }
  },
  // https://tailwindcss.com/docs/align-items
  'items-stretch': {
    output: {
      alignItems: 'stretch'
    }
  },
  'items-start': {
    output: {
      alignItems: 'flex-start'
    }
  },
  'items-center': {
    output: {
      alignItems: 'center'
    }
  },
  'items-end': {
    output: {
      alignItems: 'flex-end'
    }
  },
  'items-baseline': {
    output: {
      alignItems: 'baseline'
    }
  },
  // https://tailwindcss.com/docs/align-content
  'content-start': {
    output: {
      alignContent: 'flex-start'
    }
  },
  'content-center': {
    output: {
      alignContent: 'center'
    }
  },
  'content-end': {
    output: {
      alignContent: 'flex-end'
    }
  },
  'content-between': {
    output: {
      alignContent: 'space-between'
    }
  },
  'content-around': {
    output: {
      alignContent: 'space-around'
    }
  },
  // https://tailwindcss.com/docs/align-self
  'self-auto': {
    output: {
      alignSelf: 'auto'
    }
  },
  'self-start': {
    output: {
      alignSelf: 'flex-start'
    }
  },
  'self-center': {
    output: {
      alignSelf: 'center'
    }
  },
  'self-end': {
    output: {
      alignSelf: 'flex-end'
    }
  },
  'self-stretch': {
    output: {
      alignSelf: 'stretch'
    }
  },
  // https://tailwindcss.com/docs/justify-content
  'justify-start': {
    output: {
      justifyContent: 'flex-start'
    }
  },
  'justify-center': {
    output: {
      justifyContent: 'center'
    }
  },
  'justify-end': {
    output: {
      justifyContent: 'flex-end'
    }
  },
  'justify-between': {
    output: {
      justifyContent: 'space-between'
    }
  },
  'justify-around': {
    output: {
      justifyContent: 'space-around'
    }
  },
  // https://tailwindcss.com/docs/flex
  // https://tailwindcss.com/docs/flex-grow
  // https://tailwindcss.com/docs/flex-shrink
  // https://tailwindcss.com/docs/order
  // See dynamicStyles.js

  /**
   * ===========================================
   * Grid
   */
  // https://tailwindcss.com/docs/grid-template-columns
  // https://tailwindcss.com/docs/grid-column
  // https://tailwindcss.com/docs/grid-template-rows
  // https://tailwindcss.com/docs/grid-row
  // https://tailwindcss.com/docs/gap
  // See dynamicStyles.js
  // https://tailwindcss.com/docs/grid-auto-flow
  'grid-flow-row': {
    output: {
      gridAutoFlow: 'row'
    }
  },
  'grid-flow-col': {
    output: {
      gridAutoFlow: 'column'
    }
  },
  'grid-flow-row-dense': {
    output: {
      gridAutoFlow: 'row dense'
    }
  },
  'grid-flow-col-dense': {
    output: {
      gridAutoFlow: 'col dense'
    }
  },

  /**
   * ===========================================
   * Spacing
   */
  // https://tailwindcss.com/docs/padding
  // https://tailwindcss.com/docs/margin
  // See dynamicStyles.js

  /**
   * ===========================================
   * Sizing
   */
  // https://tailwindcss.com/docs/width
  // https://tailwindcss.com/docs/min-width
  // https://tailwindcss.com/docs/max-width
  // https://tailwindcss.com/docs/height
  // https://tailwindcss.com/docs/min-height
  // https://tailwindcss.com/docs/max-height
  // See dynamicStyles.js

  /**
   * ===========================================
   * Typography
   */
  // https://tailwindcss.com/docs/font-family
  // https://tailwindcss.com/docs/font-size
  // See dynamicStyles.js
  // https://tailwindcss.com/docs/font-smoothing
  antialiased: {
    output: {
      WebkitFontSmoothing: 'antialiased',
      MozOsxFontSmoothing: 'grayscale'
    },
    config: false
  },
  'subpixel-antialiased': {
    output: {
      WebkitFontSmoothing: 'auto',
      MozOsxFontSmoothing: 'auto'
    },
    config: false
  },
  // https://tailwindcss.com/docs/font-style
  italic: {
    output: {
      fontStyle: 'italic'
    }
  },
  'not-italic': {
    output: {
      fontStyle: 'normal'
    }
  },
  // https://tailwindcss.com/docs/font-weight
  // https://tailwindcss.com/docs/letter-spacing
  // https://tailwindcss.com/docs/line-height
  // https://tailwindcss.com/docs/list-style-type
  // See dynamicStyles.js
  // https://tailwindcss.com/docs/list-style-position
  'list-inside': {
    output: {
      listStylePosition: 'inside'
    }
  },
  'list-outside': {
    output: {
      listStylePosition: 'outside'
    }
  },
  // https://tailwindcss.com/docs/placeholder-color
  // See dynamicStyles.js
  // https://tailwindcss.com/docs/text-align
  'text-left': {
    output: {
      textAlign: 'left'
    }
  },
  'text-center': {
    output: {
      textAlign: 'center'
    }
  },
  'text-right': {
    output: {
      textAlign: 'right'
    }
  },
  'text-justify': {
    output: {
      textAlign: 'justify'
    }
  },
  // https://tailwindcss.com/docs/text-color
  // See dynamicStyles.js
  // https://tailwindcss.com/docs/text-decoration
  underline: {
    output: {
      textDecoration: 'underline'
    }
  },
  'line-through': {
    output: {
      textDecoration: 'line-through'
    }
  },
  'no-underline': {
    output: {
      textDecoration: 'none'
    }
  },
  // https://tailwindcss.com/docs/text-transform
  uppercase: {
    output: {
      textTransform: 'uppercase'
    }
  },
  lowercase: {
    output: {
      textTransform: 'lowercase'
    }
  },
  capitalize: {
    output: {
      textTransform: 'capitalize'
    }
  },
  'normal-case': {
    output: {
      textTransform: 'none'
    }
  },
  // https://tailwindcss.com/docs/vertical-align
  'align-baseline': {
    output: {
      verticalAlign: 'baseline'
    }
  },
  'align-top': {
    output: {
      verticalAlign: 'top'
    }
  },
  'align-middle': {
    output: {
      verticalAlign: 'middle'
    }
  },
  'align-bottom': {
    output: {
      verticalAlign: 'bottom'
    }
  },
  'align-text-top': {
    output: {
      verticalAlign: 'text-top'
    }
  },
  'align-text-bottom': {
    output: {
      verticalAlign: 'text-bottom'
    }
  },
  // https://tailwindcss.com/docs/whitespace
  'whitespace-normal': {
    output: {
      whiteSpace: 'normal'
    }
  },
  'whitespace-no-wrap': {
    output: {
      whiteSpace: 'nowrap'
    }
  },
  'whitespace-pre': {
    output: {
      whiteSpace: 'pre'
    }
  },
  'whitespace-pre-line': {
    output: {
      whiteSpace: 'pre-line'
    }
  },
  'whitespace-pre-wrap': {
    output: {
      whiteSpace: 'pre-wrap'
    }
  },
  // https://tailwindcss.com/docs/word-break
  'break-normal': {
    output: {
      wordBreak: 'normal',
      overflowWrap: 'normal'
    },
    config: 'wordbreak'
  },
  'break-words': {
    output: {
      overflowWrap: 'break-word'
    },
    config: 'wordbreak'
  },
  'break-all': {
    output: {
      wordBreak: 'break-all'
    },
    config: 'wordbreak'
  },
  truncate: {
    output: {
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap'
    },
    config: false
  },

  /**
   * ===========================================
   * Backgrounds
   */
  // https://tailwindcss.com/docs/background-attachment
  'bg-fixed': {
    output: {
      backgroundAttachment: 'fixed'
    }
  },
  'bg-local': {
    output: {
      backgroundAttachment: 'local'
    }
  },
  'bg-scroll': {
    output: {
      backgroundAttachment: 'scroll'
    }
  },
  // https://tailwindcss.com/docs/background-color
  // https://tailwindcss.com/docs/background-size
  // https://tailwindcss.com/docs/background-position
  // See dynamicStyles.js
  // https://tailwindcss.com/docs/background-repeat
  'bg-repeat': {
    output: {
      backgroundRepeat: 'repeat'
    }
  },
  'bg-no-repeat': {
    output: {
      backgroundRepeat: 'no-repeat'
    }
  },
  'bg-repeat-x': {
    output: {
      backgroundRepeat: 'repeat-x'
    }
  },
  'bg-repeat-y': {
    output: {
      backgroundRepeat: 'repeat-y'
    }
  },
  'bg-repeat-round': {
    output: {
      backgroundRepeat: 'round'
    }
  },
  'bg-repeat-space': {
    output: {
      backgroundRepeat: 'space'
    }
  },
  // https://tailwindcss.com/docs/background-size
  // See dynamicStyles.js

  /**
   * ===========================================
   * Borders
   */
  // https://tailwindcss.com/docs/border-color
  // See dynamicStyles.js
  // https://tailwindcss.com/docs/border-style
  'border-solid': {
    output: {
      borderStyle: 'solid'
    }
  },
  'border-dashed': {
    output: {
      borderStyle: 'dashed'
    }
  },
  'border-dotted': {
    output: {
      borderStyle: 'dotted'
    }
  },
  'border-double': {
    output: {
      borderStyle: 'double'
    }
  },
  'border-none': {
    output: {
      borderStyle: 'none'
    }
  },
  // https://tailwindcss.com/docs/border-width
  // https://tailwindcss.com/docs/border-radius
  // See dynamicStyles.js

  /**
   * ===========================================
   * Tables
   */
  // https://tailwindcss.com/docs/border-collapse
  'border-collapse': {
    output: {
      borderCollapse: 'collapse'
    }
  },
  'border-separate': {
    output: {
      borderCollapse: 'separate'
    }
  },
  // https://tailwindcss.com/docs/table-layout
  'table-auto': {
    output: {
      tableLayout: 'auto'
    }
  },
  'table-fixed': {
    output: {
      tableLayout: 'fixed'
    }
  },

  /**
   * ===========================================
   * Effects
   */
  // https://tailwindcss.com/docs/box-shadow/
  // https://tailwindcss.com/docs/opacity
  // See dynamicStyles.js

  /**
   * ===========================================
   * Transitions
   */
  // https://tailwindcss.com/docs/transition-property
  // https://tailwindcss.com/docs/transition-duration
  // https://tailwindcss.com/docs/transition-timing-function
  // See dynamicStyles.js

  /**
   * ===========================================
   * Transforms
   */
  // https://tailwindcss.com/docs/scale
  // https://tailwindcss.com/docs/rotate
  // https://tailwindcss.com/docs/translate
  // https://tailwindcss.com/docs/skew
  // https://tailwindcss.com/docs/transform-origin
  // See dynamicStyles.js

  /**
   * ===========================================
   * Interactivity
   */
  // https://tailwindcss.com/docs/appearance
  'appearance-none': {
    output: {
      appearance: 'none'
    }
  },
  // https://tailwindcss.com/docs/cursor
  // See dynamicStyles.js
  // https://tailwindcss.com/docs/outline
  'outline-none': {
    output: {
      outline: 0
    }
  },
  // https://tailwindcss.com/docs/pointer-events
  'pointer-events-none': {
    output: {
      pointerEvents: 'none'
    }
  },
  'pointer-events-auto': {
    output: {
      pointerEvents: 'auto'
    }
  },
  // https://tailwindcss.com/docs/resize
  'resize-none': {
    output: {
      resize: 'none'
    }
  },
  'resize-y': {
    output: {
      resize: 'vertical'
    }
  },
  'resize-x': {
    output: {
      resize: 'horizontal'
    }
  },
  resize: {
    output: {
      resize: 'both'
    }
  },
  // https://tailwindcss.com/docs/user-select
  'select-none': {
    output: {
      userSelect: 'none'
    }
  },
  'select-text': {
    output: {
      userSelect: 'text'
    }
  },
  'select-all': {
    output: {
      userSelect: 'all'
    }
  },
  'select-auto': {
    output: {
      userSelect: 'auto'
    }
  },

  /**
   * ===========================================
   * Svg
   */
  // https://tailwindcss.com/docs/fill
  // https://tailwindcss.com/docs/stroke
  // https://tailwindcss.com/docs/stroke
  // See dynamicStyles.js

  /**
   * ===========================================
   * Accessibility
   */
  // https://tailwindcss.com/docs/screen-readers
  'sr-only': {
    output: {
      position: 'absolute',
      width: '1px',
      height: '1px',
      padding: '0',
      margin: '-1px',
      overflow: 'hidden',
      clip: 'rect(0, 0, 0, 0)',
      whiteSpace: 'nowrap',
      borderWidth: '0'
    },
    config: 'accessibility'
  },
  'not-sr-only': {
    output: {
      position: 'static',
      width: 'auto',
      height: 'auto',
      padding: '0',
      margin: '0',
      overflow: 'visible',
      clip: 'auto',
      whiteSpace: 'normal'
    },
    config: 'accessibility'
  },

  /**
   * ===========================================
   * Special classes
   */
  transform: {
    output: {
      '--transform-translate-x': '0',
      '--transform-translate-y': '0',
      '--transform-rotate': '0',
      '--transform-skew-x': '0',
      '--transform-skew-y': '0',
      '--transform-scale-x': '1',
      '--transform-scale-y': '1',
      transform: 'translateX(var(--transform-translate-x)) translateY(var(--transform-translate-y)) rotate(var(--transform-rotate)) skewX(var(--transform-skew-x)) skewY(var(--transform-skew-y)) scaleX(var(--transform-scale-x)) scaleY(var(--transform-scale-y))'
    },
    config: false
  },

  /**
   * ===========================================
   * Extras
   * Extra styles that aren't part of Tailwind
   */
  content: {
    output: {
      content: '""'
    },
    config: false
  }
};

var isEmpty = function (value) { return value === undefined || value === null || typeof value === 'object' && Object.keys(value).length === 0 || typeof value === 'string' && value.trim().length === 0; };

var spaced = function (string) { return ("\n\n" + string + "\n"); };

var warning = function (string) { return chalk.bgBlack(chalk.hex('#ff8383')(("✕ " + string))); };

var getClassNamePieces = function (className) {
  var classNamePieces = className.split('-');
  return classNamePieces.length > 1 ? classNamePieces.slice(0, -1).join('-') : classNamePieces[0];
};

var softMatchDynamicClass = function (ref) {
  var ref$1;

  var className = ref.className;
  var obj = ref.obj;
  var configTheme = ref.configTheme;
  var prefix = ref.prefix;
  if (typeof obj !== 'object') { return []; }
  var values = Object.entries(obj).map(function (ref) {
    var key = ref[0];
    var value = ref[1];

    if (!value.config) { return []; }
    var config = dlv(configTheme, value.config);
    return Object.entries(config).map(function (ref) {
      var obj;

      var k = ref[0];
      var v = ref[1];
      var hasObjectValue = typeof v === 'object';
      var hasDefaultKey = k === 'default';
      var hasNegative = k.startsWith === '-';
      return ( obj = {}, obj[("" + (hasNegative ? '-' : '') + key + (hasDefaultKey ? '' : ("" + (hasNegative ? '' : '-') + k)) + (hasObjectValue ? chalk.hex('#999')('-xxx') : ''))] = hasObjectValue ? '' : v, obj );
    });
  });
  var combinedValues = (ref$1 = []).concat.apply(ref$1, values);
  var matches = combinedValues.filter(function (item) { return Object.keys(item)[0].startsWith(("" + prefix + className)); }).reduce(function (accumulator, item) { return (Object.assign({}, accumulator,
    item)); }, {});
  return matches;
};

var softMatchStaticClass = function (ref) {
  var className = ref.className;
  var obj = ref.obj;
  var prefix = ref.prefix;

  if (typeof obj !== 'object') { return {}; }
  var matches = Object.entries(obj).filter(function (ref) {
    var key = ref[0];
    var value = ref[1];

    return !isEmpty(value) && key.startsWith(("" + prefix + className));
  }).reduce(function (accumulator, item) {
    var obj;

    return (Object.assign({}, accumulator,
    ( obj = {}, obj[item[0]] = '', obj )));
  }, {});
  return matches;
};

var softMatchDynamicConfig = function (ref) {
  var className = ref.className;
  var configTheme = ref.configTheme;
  var prefix = ref.prefix;

  var properties = {
    obj: dynamicStyles,
    configTheme: configTheme,
    prefix: prefix
  };
  var config = softMatchDynamicClass(Object.assign({}, properties,
    {className: className}));
  var classNamePieceCheck = getClassNamePieces(className);
  return !isEmpty(config) ? config : softMatchDynamicClass(Object.assign({}, properties,
    {className: classNamePieceCheck}));
};

var softMatchStaticConfig = function (ref) {
  var className = ref.className;
  var prefix = ref.prefix;

  var properties = {
    obj: staticStyles,
    prefix: prefix
  };
  var config = softMatchStaticClass(Object.assign({}, properties,
    {className: className}));
  var classNamePieceCheck = getClassNamePieces(className);
  return !isEmpty(config) ? config : softMatchStaticClass(Object.assign({}, properties,
    {className: classNamePieceCheck}));
}; // Get soft matches from the static and dynamic configs for suggestions


var softMatchConfigs = function (properties) { return (Object.assign({}, softMatchDynamicConfig(properties),
  softMatchStaticConfig(properties))); };

var logInOut = function (input, output) { return ((chalk.greenBright('✓')) + " " + input + " " + (chalk.greenBright(JSON.stringify(output)))); };

var logNoVariant = function (variant, validModifiers) { return spaced(((warning(("The variant “" + variant + ":” is unavailable."))) + "\n\nTry one of these variants:\n" + (validModifiers.map(function (item, index) { return ("" + (validModifiers.length > 6 && index % 6 === 0 && index > 0 ? '\n' : '') + (chalk.yellowBright(item)) + ":"); }).join(chalk.gray(' / '))))); };

var suggestions = function (ref) {
  var config = ref.config;

  if (!config) { return ''; }
  if (Object.keys(config).length === 0) { return ''; }
  var configLength = Object.entries(config).length; // Single suggestion

  if (configLength === 1) { return ("\n\nDid you mean " + (chalk.yellowBright(Object.keys(config).join())) + "?"); } // Multiple suggestions

  var lineLength = 0;
  return ("\n\nTry one of these classes:\n" + (Object.entries(config).map(function (ref, index) {
    var key = ref[0];
    var value = ref[1];

    var displayValue = value ? (" " + (chalk.hex('#999')(("[" + value + "]")))) : '';
    var result = "" + (key !== 'undefined' ? key : '') + displayValue;
    lineLength = lineLength + ("" + key + value).length;
    var divider = lineLength > 60 ? '\n' : index !== Object.entries(config).length - 1 ? chalk.gray(" / ") : '';
    if (lineLength > 60) { lineLength = 0; }
    return ("" + (chalk.yellowBright(result)) + divider);
  }).join('')));
};

var logNoClass = function (ref) {
  var className = ref.className;
  var config = ref.config;
  var hasSuggestions = ref.hasSuggestions;

  return spaced(("" + (warning(((className ? chalk.hex('#ffd3d3')(className) : 'Class') + " was not found"))) + (hasSuggestions ? suggestions({
  config: config
}) : '')));
};

var logNoTrailingDash = function (className) { return spaced(warning(("Class “" + className + "” shouldn’t have a trailing dash."))); };

var logBadGood = function (bad, good) { return ((chalk.hex('#ff8383')('✕ Bad:')) + " " + bad + "\n" + (chalk.greenBright('✓ Good:')) + " " + good); };

var stringifyScreen = function (config, screenName) {
  var screen = dlv(config, ['theme', 'screens', screenName]);

  if (typeof screen === 'undefined') {
    throw new Error(("Couldn’t find Tailwind the screen \"" + screenName + "\" in the Tailwind config"));
  }

  if (typeof screen === 'string') { return ("@media (min-width: " + screen + ")"); }

  if (typeof screen.raw === 'string') {
    return ("@media " + (screen.raw));
  }

  var string = (Array.isArray(screen) ? screen : [screen]).map(function (range) {
    return [typeof range.min === 'string' ? ("(min-width: " + (range.min) + ")") : null, typeof range.max === 'string' ? ("(max-width: " + (range.max) + ")") : null].filter(Boolean).join(' and ');
  }).join(', ');
  return string ? ("@media " + string) : '';
};

var orderByScreens = function (classNames, screens) {
  var screenCompare = function (a, b) {
    var A = a.includes(':') ? a.split(':')[0] : a;
    var B = b.includes(':') ? b.split(':')[0] : b;
    return screens.indexOf(A) < screens.indexOf(B) ? -1 : 1;
  }; // Tim Sort provides accurate sorting in node < 11
  // https://github.com/ben-rogerson/twin.macro/issues/20


  timSort.sort(classNames, screenCompare);
  return classNames;
};

var assert = function (expression, error) {
  if (!expression) { return; }
  throw new babelPluginMacros.MacroError(error);
};

var isEmpty$1 = function (value) { return value === undefined || value === null || typeof value === 'object' && Object.keys(value).length === 0 || typeof value === 'string' && value.trim().length === 0; };

var styleify = function (ref) {
  var obj;

  var prop = ref.prop;
  var value = ref.value;
  return Array.isArray(prop) ? prop.reduce(function (accumulator, item) {
  var obj;

  return (Object.assign({}, accumulator,
  ( obj = {}, obj[item] = value, obj )));
  }, {}) : ( obj = {}, obj[prop] = value, obj );
};
/**
 * Matches
 */


function matchString(value) {
  if (typeof value !== 'string') { return; }
  return value;
}

function matchNumberAsString(value) {
  if (typeof value !== 'number') { return; }
  return String(value);
}

function matchDefaultValue(value) {
  if (typeof value !== 'object') { return; }
  if (!value.default) { return; }
  return value.default;
}

function matchObject(value) {
  if (!value) { return; }
  if (typeof value !== 'object') { return; }
  return value;
}

function checkNewStyle(ref) {
  var config = ref.config;
  var key = ref.key;
  var prop = ref.prop;

  // String-ish
  var stringMatch = matchString(config[key]) || matchNumberAsString(config[key]);

  if (stringMatch) {
    return styleify({
      prop: prop,
      value: stringMatch
    });
  } // Default


  var defaultValueMatch = matchDefaultValue(config[key]);

  if (defaultValueMatch) {
    return styleify({
      prop: prop,
      value: defaultValueMatch
    });
  } // Font family


  if (prop === 'fontFamily') {
    var objectMatch$1 = matchObject(config[key]);

    if (objectMatch$1 && Array.isArray(Object.values(objectMatch$1))) {
      return styleify({
        prop: prop,
        value: Object.values(objectMatch$1).join(', ')
      });
    }
  } // Object


  var objectMatch = matchObject(config[key]);

  if (objectMatch) {
    var newStyleCheck = checkNewStyle({
      config: Object.values(objectMatch),
      key: key,
      prop: prop
    });

    if (newStyleCheck) {
      return newStyleCheck;
    }
  }
}

function resolveStyleFromPlugins(ref) {
  var config = ref.config;
  var className = ref.className;

  var pluginClassNames = {};

  if (!config.plugins || config.plugins.length === 0) {
    return;
  }

  var processedPlugins = processPlugins(config.plugins, config); // Only plugin utilities for now, plugin components are much more complex
  // This mimics the tailwind.macro functionality

  processedPlugins.utilities.forEach(function (rule) {
    if (rule.type !== 'atrule' || rule.name !== 'variants') {
      return;
    }

    rule.each(function (x) {
      var match = x.selector.match(/^\.(\S+)(\s+.*?)?$/);

      if (match === null) {
        return;
      }

      var name = match[1];
      var rest = match[2];
      var keys = rest ? [name, rest.trim()] : [name];
      dset(pluginClassNames, keys, {});
      x.walkDecls(function (decl) {
        dset(pluginClassNames, keys.concat(decl.prop), decl.value);
      });
    });
  });
  var output = typeof pluginClassNames[className] !== 'undefined' ? pluginClassNames[className] : null;
  return output;
}

function resolveStyle(properties) {
  var styleList = properties.styleList;
  var key = properties.key;
  var className = properties.className;
  var prefix = properties.prefix;
  var config = properties.config;
  var hasSuggestions = properties.hasSuggestions; // Deal with Array items like 'font' or 'bg'

  if (Array.isArray(styleList)) {
    var resultsRaw = styleList.map(function (item) { return resolve.apply(void 0, [ item ].concat( properties )); });
    var results = Object.values(resultsRaw).find(function (x) { return x && Object.values(x)[0] !== undefined; });
    assert(!results, // TODO: Add class suggestions for these types
    logNoClass({
      className: ("" + prefix + className),
      hasSuggestions: hasSuggestions
    }));
    return results;
  }

  if (typeof styleList === 'object') {
    var results$1 = resolve.apply(void 0, [ styleList ].concat( properties ));
    assert(isEmpty$1(results$1), logNoClass({
      className: ("" + prefix + className),
      hasSuggestions: hasSuggestions,
      config: softMatchConfigs({
        className: className,
        configTheme: config.theme,
        prefix: prefix
      })
    }));
    return results$1;
  }

  throw new babelPluginMacros.MacroError(("\"" + className + "\" requires \"" + key + "\" in the Tailwind config"));
}

function resolve(opt, ref) {
  var config = ref.config;
  var key = ref.key;
  var className = ref.className;
  var prefix = ref.prefix;

  // Get the key from classNames style config
  var findKey = dlv(config, ['theme', opt.config], {}); // Check the key is defined in the tailwind config

  var checkValidConfig = matchObject(findKey);
  assert(!checkValidConfig, (className + " expects " + (opt.config) + " in the Tailwind config")); // Check for hyphenated key matches eg: row-span-2 ("span-2" being the key)

  var keyMatch = findKey[("" + prefix + (key || 'default'))] || null;

  if (keyMatch) {
    var stringResults = checkNewStyle({
      config: findKey,
      key: ("" + prefix + (key || 'default')),
      prop: opt.prop
    });

    if (stringResults) {
      return stringResults;
    }
  } // Check using className splitting


  var classParts = className && className.includes('-') ? className.split('-').filter(Boolean) : [className];
  var index = 0; // Match parts of the classname against the config

  for (var i = 0, list = Object.entries(classParts); i < list.length; i += 1) {
    var item = list[i];

    var index$1 = item[0];
    var part = item[1];
    var partFound = Object.keys(findKey).includes(part);

    if (partFound) {
      var value = findKey[part] || null;

      if (value) {
        var newKey = classParts[Number(index$1) + 1];
        var stringResults$1 = checkNewStyle({
          config: value,
          key: newKey,
          prop: opt.prop
        });

        if (stringResults$1) {
          return stringResults$1;
        }
      }
    }
  }
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */


  for (var i$1 = 0, list$1 = classParts; i$1 < list$1.length; i$1 += 1) {

    index = index + 1;
    var keyNext = classParts[index] ? classParts[index] : null;
    var keyFound = findKey[("" + prefix + keyNext)];

    if (keyFound) {
      var stringResults$2 = checkNewStyle({
        className: className,
        config: keyFound,
        key: key,
        prop: opt.prop
      });

      if (stringResults$2) {
        return styleify({
          prop: opt.prop,
          value: stringResults$2
        });
      }
    }
  }

  return {};
}

function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }
var modifierList = {
  'group-hover': '.group:hover &',
  'focus-within': ':focus-within',
  first: ':first-child',
  last: ':last-child',
  odd: ':nth-child(odd)',
  even: ':nth-child(even)',
  hover: ':hover',
  focus: ':focus',
  active: ':active',
  visited: ':visited',
  disabled: ':disabled',
  // Custom to Twin
  'group-hocus': '.group:hover &, .group:focus &',
  'group-focus': '.group:focus &',
  'group-active': '.group:active &',
  'group-visited': '.group:visited &',
  hocus: ':hover, :focus',
  before: ':before',
  after: ':after'
};
/**
 * Merge the modifiers
 */

var mergeVariants = function (ref) {
  var variants = ref.variants;
  var objBase = ref.objBase;
  var objToMerge = ref.objToMerge;

  if (!objToMerge) { return objBase; }

  if (variants.length === 0) {
    return Object.assign({}, objBase,
      objToMerge);
  } // TODO: Replace dset


  dset(objBase, variants, Object.assign({}, dlv(objBase, variants, {}),
    objToMerge));
  return objBase;
};
/**
 * Validate modifiers against the variants config key
 */


var validateVariants = function (ref) {
  var modifiers = ref.modifiers;
  var state = ref.state;

  if (!modifiers) { return []; }
  var themeScreens = dlv(state.config, ['theme', 'screens']);
  var themeScreenKeys = Object.keys(themeScreens);
  var validModifiers = Object.keys(modifierList).concat( themeScreenKeys);
  return modifiers.map(function (modifier) {
    var isModifierResponsive = themeScreenKeys && themeScreenKeys.includes(modifier);

    if (isModifierResponsive) {
      return state.isProd ? stringifyScreen(state.config, modifier) : ("" + COMPUTED_ID + (state.tailwindUtilsIdentifier.name) + ".stringifyScreen(" + (state.tailwindConfigIdentifier.name) + ", \"" + modifier + "\")");
    } // Check modifier against available modifiers


    if (modifierList[modifier]) {
      return modifierList[modifier];
    }

    throw new babelPluginMacros.MacroError(logNoVariant(modifier, validModifiers));
  }).filter(Boolean);
};
/**
 * Split the variant(s) from the className
 */


var splitVariants = function (ref) {
  var className = ref.className;
  var rest$1 = objectWithoutProperties( ref, ["className"] );
  var rest = rest$1;

  var modifiers = [];
  var modifier;

  while (modifier !== null) {
    modifier = className.match(/^([_a-z-]+):/);

    if (modifier) {
      className = className.slice(modifier[0].length);
      modifiers.push(modifier[1]);
    }
  }

  return Object.assign({}, rest,
    {className: className,
    modifiers: modifiers});
};

/**
 * Add important to a value
 */
function objectWithoutProperties$1 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }
var mergeImportant = function (object, hasImportant) {
  if (!hasImportant) { return object; }
  return Object.entries(object).reduce(function (accumulator, item) {
    var obj;

    var key = item[0];
    var value = item[1];

    if (typeof value === 'object') {
      return mergeImportant(value, hasImportant);
    }

    return Object.assign({}, accumulator,
      ( obj = {}, obj[key] = (value + " !important"), obj ));
  }, {});
};
/**
 * Split the important from the className
 */


var splitImportant = function (ref) {
  var className = ref.className;
  var rest$1 = objectWithoutProperties$1( ref, ["className"] );
  var rest = rest$1;

  var lastCharacter = className.slice(-1);
  var hasImportant = lastCharacter === '!';

  if (hasImportant) {
    className = className.slice(0, -1);
  }

  return Object.assign({}, rest,
    {className: className,
    hasImportant: hasImportant});
};

/**
 * Split the negative from the className
 */
function objectWithoutProperties$2 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }
var splitNegative = function (ref) {
  var className = ref.className;
  var rest$1 = objectWithoutProperties$2( ref, ["className"] );
  var rest = rest$1;

  var hasNegative = className.slice(0, 1) === '-';

  if (hasNegative) {
    className = className.slice(1, className.length);
  }

  return Object.assign({}, rest,
    {className: className,
    hasNegative: hasNegative});
};

var splitter = function (className) { return splitNegative(splitImportant(splitVariants({
  className: className
}))); };

var properties = function (type) { return ({
  left: (type + "Left"),
  right: (type + "Right")
}); };

var getSpacingFromArray = function (ref) {
  var obj;

  var values = ref.values;
  var left = ref.left;
  var right = ref.right;
  if (!Array.isArray(values)) { return; }
  var valueLeft = values[0];
  var valueRight = values[1];
  return ( obj = {}, obj[left] = valueLeft, obj[right] = valueRight, obj );
};

var getSpacingStyle = function (type, values, key) {
  var obj;

  if (Array.isArray(values) || typeof values !== 'object') { return; }
  var propertyValue = values[key] || {};
  if (isEmpty$1(propertyValue)) { return; }
  var objectArraySpacing = getSpacingFromArray(Object.assign({}, {values: propertyValue},
    properties(type)));
  if (objectArraySpacing) { return objectArraySpacing; }
  return ( obj = {}, obj[properties(type).left] = propertyValue, obj[properties(type).right] = propertyValue, obj );
};

var getContainerStyles = function (ref) {
  var screens = ref.screens;
  var padding = ref.padding;
  var margin = ref.margin;
  var center = ref.center;

  var mediaScreens = Object.entries(screens).reduce(function (accumulator, ref) {
    var obj;

    var key = ref[0];
    var value = ref[1];
    return (Object.assign({}, accumulator,
    ( obj = {}, obj[("@media (min-width: " + value + ")")] = Object.assign({}, {maxWidth: value},
      getSpacingStyle('padding', padding, key),
      (!center && getSpacingStyle('margin', margin, key))), obj )));
  }, {});
  var paddingStyles = Array.isArray(padding) ? getSpacingFromArray(Object.assign({}, {values: padding},
    properties('padding'))) : typeof padding === 'object' ? getSpacingStyle('padding', padding, 'default') : {
    paddingLeft: padding,
    paddingRight: padding
  };
  var marginStyles = Array.isArray(margin) ? getSpacingFromArray(Object.assign({}, {values: margin},
    properties('margin'))) : typeof margin === 'object' ? getSpacingStyle('margin', margin, 'default') : {
    marginLeft: margin,
    marginRight: margin
  }; // { center: true } overrides any margin styles

  if (center) { marginStyles = {
    marginLeft: 'auto',
    marginRight: 'auto'
  }; }
  return Object.assign({}, {width: '100%'},
    paddingStyles,
    marginStyles,
    mediaScreens);
};

function getStyles(string, t, state) {
  // Move and sort the responsive items to the end of the list
  var classList = string.match(/\S+/g) || [];
  var configScreens = Object.keys(state.config.theme.screens);
  var classListOrdered = orderByScreens(classList, configScreens);
  var styles = classListOrdered.reduce(function (accumulator, classNameRaw, index) {
    var obj;

    assert(classNameRaw === 'group', ("\"group\" must be added as className:\n\n" + (logBadGood('tw`group`', '<div className="group">')) + "\n"));
    assert(classNameRaw.endsWith('-'), logNoTrailingDash(classNameRaw));

    if (['container'].includes(classNameRaw)) {
      var ref = dlv(state, ['config', 'theme']);
      var container = ref.container;
      var screens = ref.screens;
      var containerStyles = getContainerStyles(Object.assign({}, container,
        {screens: screens}));

      if (containerStyles) {
        state.debug && console.log(logInOut(classNameRaw, containerStyles));
        return containerStyles;
      }
    }

    var ref$1 = splitter(classNameRaw);
    var className = ref$1.className;
    var modifiers = ref$1.modifiers;
    var hasImportant = ref$1.hasImportant;
    var hasNegative = ref$1.hasNegative;
    var prefix = hasNegative ? '-' : ''; // Match the filtered modifiers

    var matchedVariants = validateVariants({
      modifiers: modifiers,
      state: state
    }); // Match against plugin classNames

    var pluginMatch = resolveStyleFromPlugins({
      config: state.config,
      className: className
    });

    if (pluginMatch) {
      var important = mergeImportant(pluginMatch, hasImportant);
      var pluginOutput = mergeVariants({
        variants: matchedVariants,
        objBase: accumulator,
        objToMerge: important
      });
      state.debug && console.log(logInOut(className, important));
      return pluginOutput;
    }

    var staticConfig = dlv(staticStyles, [className, 'config']);
    var staticConfigOutput = dlv(staticStyles, [className, 'output']);
    var staticConfigKey = staticConfigOutput ? Object.keys(staticConfigOutput).shift() : null;
    var staticStyleKey = staticConfig || staticConfigKey; // Get an array of matches (eg: ['col', 'col-span'])

    var dynamicKeyMatches = Object.keys(dynamicStyles).filter(function (k) { return className.startsWith(k + '-') || className === k; }) || []; // Get the best match from the match array

    var dynamicKey = dynamicKeyMatches.reduce(function (r, match) { return r.length < match.length ? match : r; }, []);
    var dynamicStyleset = dlv(dynamicStyles, dynamicKey);
    var dynamicStyleKey = Array.isArray(dynamicStyleset) ? dynamicStyleset.map(function (i) { return dlv(i, 'config'); }) : dlv(dynamicStyles, [dynamicKey, 'config']); // Exit early if no className is found in both configs

    assert(!staticStyleKey && !dynamicStyleKey, logNoClass({
      className: ("" + prefix + className),
      config: softMatchConfigs({
        className: className,
        configTheme: state.config.theme,
        prefix: prefix
      }),
      hasSuggestions: state.hasSuggestions
    }));

    if (staticStyleKey) {
      var staticStyleOutput = dlv(staticStyles, [className, 'output']);
      assert(!staticStyleOutput, ("No output value found for " + className + " in static config"));
      var important$1 = mergeImportant(staticStyleOutput, hasImportant);
      var mergedStaticOutput = mergeVariants({
        variants: matchedVariants,
        objBase: accumulator,
        objToMerge: important$1
      });
      state.debug && console.log(logInOut(className, important$1));
      return state.isProd ? mergedStaticOutput : ''; // [c]:
      //   COMPUTED_ID +
      //   pre +
      //   state.tailwindConfigIdentifier.name +
      //   '.theme.' +
      //   styleConfigKey +
      //   '["' +
      //   key +
      //   '"]'
    }

    var key = className.slice(dynamicKey.length + 1);
    var results = state.isProd ? resolveStyle({
      config: state.config,
      styleList: dynamicStyleset,
      key: key,
      className: className,
      matchedKey: dynamicKey,
      prefix: prefix,
      hasSuggestions: state.hasSuggestions
    }) : ( obj = {}, obj[("" + SPREAD_ID + index)] = ((state.tailwindUtilsIdentifier.name) + ".resolveStyle(\"" + (state.tailwindConfigIdentifier.name) + ", " + (JSON.stringify(dynamicStyles[dynamicKey])) + ", \"" + key + "\")"), obj );
    var dynamicStyleImportant = mergeImportant(results, hasImportant); // The placeholder class requires a custom prefix

    var isPlaceholder = className.startsWith('placeholder-');
    var dynamicStylePlaceholder = isPlaceholder ? {
      '::placeholder': dynamicStyleImportant
    } : dynamicStyleImportant;
    var mergedDynamicOutput = mergeVariants({
      variants: matchedVariants,
      objBase: accumulator,
      objToMerge: dynamicStylePlaceholder
    }); // TODO: Find how to add variants to debug (eg: media queries, before)

    state.debug && console.log(logInOut(className, dynamicStylePlaceholder));
    return mergedDynamicOutput;
  }, {});
  var ast = state.isDev ? assignify(styles, t) : astify(styles, t);
  return ast;
}

var TW_CONFIG_DEFAULT_FILENAME = 'tailwind.config.js';

var addDevelopmentImports = function (ref) {
  var state = ref.state;
  var configPath = ref.configPath;
  var program = ref.program;
  var t = ref.t;
  var configExists = ref.configExists;

  var tailwindConfigUid = program.scope.generateUidIdentifier('tailwindConfig'); // Call resolveConfig function from the utils file
  // For hot tailwind.config updates
  // eg: const _tailwindConfig = _tailwindUtils.resolveConfig()

  program.unshiftContainer('body', t.variableDeclaration('const', [t.variableDeclarator(state.tailwindConfigIdentifier, t.callExpression(t.memberExpression(state.tailwindUtilsIdentifier, t.identifier('resolveConfig')), [configExists ? tailwindConfigUid : t.objectExpression([])]))])); // Import users tailwind.config.js for hot config updates

  if (configExists) {
    var tailwindConfigImportPath = "./" + (path.relative(path.dirname(state.file.opts.filename), configPath));
    addImport({
      types: t,
      program: program,
      mod: tailwindConfigImportPath,
      name: 'default',
      identifier: tailwindConfigUid
    });
  } // Import the utils


  addImport({
    types: t,
    program: program,
    mod: 'twin.macro/utils.umd',
    name: 'default',
    identifier: state.tailwindUtilsIdentifier
  });
};

var twinMacro = function (ref) {
  var t = ref.babel.types;
  var references = ref.references;
  var state = ref.state;
  var config = ref.config;

  var sourceRoot = state.file.opts.sourceRoot || '.';
  var program = state.file.path;
  var configFile = config && config.config;
  var configPath = path.resolve(sourceRoot, configFile || ("./" + TW_CONFIG_DEFAULT_FILENAME));
  var configExists = fs.existsSync(configPath);
  state.tailwindConfigIdentifier = program.scope.generateUidIdentifier('tailwindConfig');
  state.tailwindUtilsIdentifier = program.scope.generateUidIdentifier('tailwindUtils');
  /* eslint-disable-next-line unicorn/prevent-abbreviations */

  var isDev = process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'dev' || false;
  state.isDev = isDev;
  state.isProd = !isDev; // Dev mode coming soon

  if (isDev) {
    state.isDev = false;
    state.isProd = true;
  }

  var tailwindConfig = configExists ? resolveTailwindConfig([require(configPath), defaultTailwindConfig]) : resolveTailwindConfig([defaultTailwindConfig]);
  state.config = tailwindConfig;

  if (!tailwindConfig) {
    throw new babelPluginMacros.MacroError("Couldn’t find the Tailwind config");
  }

  var styledImport = config && config.styled ? {
    import: config.styled.import || 'default',
    from: config.styled.from || config.styled
  } : {
    import: 'default',
    from: '@emotion/styled'
  }; // state.existingStyledIdentifier =
  //   state.styledIdentifier === null ? false : true
  // state.styledIdentifier = findIdentifier({
  //   program,
  //   mod: styledImport.from,
  //   name: styledImport.import
  // })
  // if (!state.existingStyledIdentifier) {
  //   state.styledIdentifier = program.scope.generateUidIdentifier('styled')
  // }

  state.existingStyledIdentifier = false;
  state.styledIdentifier = findIdentifier({
    program: program,
    mod: styledImport.from,
    name: styledImport.import
  });

  if (state.styledIdentifier === null) {
    state.styledIdentifier = program.scope.generateUidIdentifier('styled');
  } else {
    state.existingStyledIdentifier = true;
  }

  state.debug = config.debug || false;
  state.configExists = configExists; // TODO: Disable suggestions in prod

  state.hasSuggestions = typeof config.hasSuggestions === 'undefined' ? true : config.hasSuggestions;
  program.traverse({
    JSXAttribute: function JSXAttribute(path$$1) {
      if (path$$1.node.name.name !== 'tw') { return; }
      var styles = getStyles(path$$1.node.value.value, t, state);
      var attributes = path$$1.findParent(function (p) { return p.isJSXOpeningElement(); }).get('attributes');
      var cssAttributes = attributes.filter(function (p) { return p.node.name && p.node.name.name === 'css'; });

      if (cssAttributes.length > 0) {
        path$$1.remove();
        var expr = cssAttributes[0].get('value').get('expression');

        if (expr.isArrayExpression()) {
          expr.pushContainer('elements', styles);
        } else {
          expr.replaceWith(t.arrayExpression([expr.node, styles]));
        }
      } else {
        path$$1.replaceWith(t.jsxAttribute(t.jsxIdentifier('css'), t.jsxExpressionContainer(styles)));
      }
    }

  });
  references.default.forEach(function (path$$1) {
    var parent = path$$1.findParent(function (x) { return x.isTaggedTemplateExpression(); });
    if (!parent) { return; }
    var parsed = parseTte({
      path: parent,
      types: t,
      styledIdentifier: state.styledIdentifier,
      state: state
    });
    if (!parsed) { return; }
    replaceWithLocation(parsed.path, getStyles(parsed.string, t, state));
  });

  if (state.shouldImportStyled && !state.existingStyledIdentifier) {
    addImport({
      types: t,
      program: program,
      mod: styledImport.from,
      name: styledImport.import,
      identifier: state.styledIdentifier
    });
  }

  if (state.isDev) {
    addDevelopmentImports({
      state: state,
      configPath: configPath,
      program: program,
      t: t,
      configExists: configExists
    });
  }

  program.scope.crawl();
};

var macro = babelPluginMacros.createMacro(twinMacro, {
  configName: 'twin'
});

module.exports = macro;
//# sourceMappingURL=macro.js.map
